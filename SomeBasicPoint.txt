1. 引用作为函数参数有哪些特点
    （a）传递函引用给函数和传递指针的效果是一样的（改变它的值，函数结束后，该引用对应位置上变量的值也改变了）
    （b）使用引用传递函数的参数，在内存中没有产生实参的副本，而是直接对实参进行操作；如果传递的是对象（而不是引用），则除了复制对象副本以外，还需要调
    用拷贝构造函数；因此如果参数传递的数据较大时，用引用比用变量的效率和所占空间都好
    （c）如果既要提高程序效率，又要保护传递给函数的数据不再函数内被改变，则使用常引用

2. C++中的临时对象都是const类型的，例如下例：
    string foo();
    void bar(string &s);
    // 则以下表达式是非法的
    bar(foo());             // foo在上面还没有初始化里面的值，所以在此处还是临时变量，是const类型的
    bar("hello, kaito");    // bar函数的传入参数应该是string类型，而"hello, kaito"是const char *类型，所以经过隐式类型转换成string类型的临时变
    量，也是const类型的

3. 引用作为函数返回值
    （a）不能返回局部变量的引用（因为当退出函数时，局部变量就被释放了，引用所指向位置的对象不存在，则引用也不存在）
    （b）不能返回函数内部new分配的内存的引用（在调用这种函数的地方，不会去释放函数体内new的内存空间，因此会导致内存泄漏）
    （c）可以返回类成员的引用，但是最好用const（因为类成员是不希望被外部修改，而返回一个类内部成员的引用，就相当于给外部提供了一个修改成员的途径）

4. C++面向对象编程的3个基本特征
    （a）封装：将客观事物抽象为类，每个类对其内部的数据和方法（成员函数）实行保护protection（private，protected，public）
    （b）继承
    （c）多态：系统在运行时，能够根据具体类型确定调用哪一个成员函数

5. 深拷贝和浅拷贝
    该问题会出现在类的拷贝函数中。假设一个类的成员变量中存在指针类型，可以用于指向片内存空间，当我们用已有的一个对象去初始化新的对象时，到底是否要给
    新的对象中指针指向的位置new一片新的内存呢？如果new了新的内存，就是深拷贝；如果没有new新的内存，就是浅拷贝；
    对于浅拷贝，在对象释放的过程中会出现问题，如果我们释放了原来的对象，则也释放了成员变量中指针指向的那片内存，则当释放新对象的时候，再次释放这片已
    经被释放的内存就会报错，解决办法就是深拷贝
    
6. 当一个类Kaito中没有申明任何成员变量和成员函数的时候，sizeof(A)的大小是0吗？如果不是0，为什么？
    不是0，因为如果用该类型定义一个数组的时候，比如Kaito p[10]，其中每个元素的大小不知道，则无法获知该开辟多大的空间，所以必须不为0；
    在visual studio中，如果什么都没有，sizeof(Kaito) = 1
    如果有任何普通成员函数，包括构造函数和析构函数，sizeof(Kaito) = 1
    如果有函数被标记为virtual，则需要构建一个虚函数表，这时候就会有一个用于指向虚函数表的指针，就会多个指针的大小，sizeof(Kaito) = 4/8(32位/64位)

7. const和#define的区别
    （a）const有数据类型，#define只是字符替换；因此编译器可以对const进行类型检查，但是#define没有
    （b）在一些集成化的调试工具可以对const进行调试，但是#define不行
    （c）#define作用在预处理阶段，const作用在编译阶段

8. 说出const尽可能多的作用
    （a）作用在全局常量，可以防止该常量在程序的任意位置被改变，因为该常量存放在常量区，只读
    （b）作用在函数的形式参数，可以防止函数体内对传入的参数所在内存位置的内容进行修改
    （c）用来修饰指针
        const int* p1;  // 该指针指向的对象只能是const int类型的，但是可以指向任意const int类型的对象
        int const* p2;  // 该指针只能指向一个地址，不能改变其指向的位置
    （d）用在类成员函数的参数列表的后面，表示该函数不能修改类中的成员变量
    （e）作用在类成员函数的返回值，使该返回得到的对象不能被作为左值（即不能对其内容进行修改）

9. 说出static尽可能多的作用
    （a）作用于局部变量，则该变量被存放在静态数据区，在多次调用该变量所在函数时，其值是上一次的值，且在第一次定义的时候，其值初始化为0
    （b）作用在函数名前，表示该函数只能被本文件内的其它函数调用，不能被其它文件使用
    （c）作用在全局变量前，表示该变量只能被本文件使用，不能被其它文件使用（因此其它文件也可以定义相同的变量名），且初始化为0
    （d）作用在类中的成员变量前，所有该类对象共享一份该变量，即该成员变量无论定义多少对象都只有一份
    （e）作用在类成员函数前，所有类对象共用该函数，且该函数不接受this指针，因此无法确定具体对象的成员变量，只能访问static的变量

10. 在结构体的最后定义一个长度为0的字符数组的操作
    在很多地方会看到定义结构体时，会在最后添加一个长度为0的char型数组，如下：
    struct Buffer {
        unsigned int a;
        char p[0];
    };
    这里面的char p[0]不会影响结构体的大小，即sizeof(struct Buffer)任然为4；p只是指向内存中该结构体尾部后面的那一段内存，比如：
    std::cout << sizeof(struct Buffer) << std::endl;
    struct Buffer *buf = (struct Buffer *)malloc(sizeof(struct Buffer) + 20);   // 此处malloc多分配了20 字节，则p就会指向这部分的起始地址
    buf->a = 2;
    memcpy(buf->p, "kaito is the best", 18);
    std::cout << buf->a << ' ' << buf->p << std::endl;
    free(buf);

11. 虚函数和多态
    /* 基类 */
    class Cache {
    public:
        virtual void show() { std::cout << "Base" << std::endl; }
    };
    /* 派生类 */
    class ICache : public Cache {
    public:
        void show() { std::cout << "Derived" << std::endl; }
    };
    /* 使用 */
    Cache cache;        // 基类对象
    ICache ic;          // 派生类对象
    ic.show();          // 使用派生类成员函数
    cache.show();       // 使用类成员函数
    ICache *p1 = &ic;   // 派生类指针，指向派生类
    p1->show();         // 使用派生类成员函数
    Cache *p2 = &ic;    // 基类指针，指向派生类
    p2->show();         // 使用派生类成员函数
    /* 输出 */
    Derived
    Base
    Derived
    Derived
    注意：
    （a）构造函数不能设置为虚函数，但是析构函数可以设置成虚函数
    （b）含有纯虚函数的类称为抽象类，抽象类不能用于定义对象，只能定义指针

12. STL中的set
    set以RB-Tree作为底层容器
    所得元素只有key，没有value，value就是key
    不允许出现重复的键值
    所有元素都会被自动排序
    不能通过迭代器来改变set的值

13. STL中的map
    map以RB-Tree作为底层容器
    所有元素都是key+value的存在
    不允许出现重复的键值
    所有元素都是通过key进行自动排序的
    map的key是不能修改的，但是key所对应的value是可以修改的

14. C++如何判断new分配内存成功
    使用try来使用new分配内存，使用catch来捕获异常并处理
    int *p[1000];
    int t = 0;
    try {
        while (1) {
            int *tmp = new int[1024 * 1024];
            if (!tmp)
                break;
            else
                p[t++] = tmp;
        }
    }
    catch (exception &exp) {
        cerr << exp.what() << endl;
        for (int i = 1; i < t; i++)
            delete p[i];
    }
    p[0][4] = 1995;
    std::cout << p[0][4] << std::endl;
    std::cout << t * 4 << " MB has been allocated successfully!" << std::endl;

15. C语言参数的入栈顺序?为什么这么实现?
    (1) 在函数调用时，函数参数的传递，在C语言中是通过栈数据结构实现的
    (2) 对于参数固定的函数，无论是从左向右还是从右向左，都没什么区别，最终都是所有参数全部传递
    (3) 对于可变参数，比如printf，会在第一个参数格式字符串中，指明后续有几个参数，各自是什么类型的。于是在函数中，参数格式字符串必须第一个弹栈，否则
    无法获取参数类型，也就无法获知后续参数占几个字节，导致无法正确获知参数。
