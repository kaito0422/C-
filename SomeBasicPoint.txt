1. 引用作为函数参数有哪些特点
    （a）传递函引用给函数和传递指针的效果是一样的（改变它的值，函数结束后，该引用对应位置上变量的值也改变了）
    （b）使用引用传递函数的参数，在内存中没有产生实参的副本，而是直接对实参进行操作；如果传递的是对象（而不是引用），则除了复制对象副本以外，还需要调用
         拷贝构造函数；因此如果参数传递的数据较大时，用引用比用变量的效率和所占空间都好
    （c）如果既要提高程序效率，又要保护传递给函数的数据不再函数内被改变，则使用常引用

2. C++中的临时对象都是const类型的，例如下例：
    string foo();
    void bar(string &s);
    // 则以下表达式是非法的
    bar(foo());             // foo在上面还没有初始化里面的值，所以在此处还是临时变量，是const类型的
    bar("hello, kaito");    // bar函数的传入参数应该是string类型，而"hello, kaito"是const char *类型，所以经过隐式类型转换成string类型的临时变
    量，也是const类型的

3. 引用作为函数返回值
    （a）不能返回局部变量的引用（因为当退出函数时，局部变量就被释放了，引用所指向位置的对象不存在，则引用也不存在）
    （b）不能返回函数内部new分配的内存的引用（在调用这种函数的地方，不会去释放函数体内new的内存空间，因此会导致内存泄漏）
    （c）可以返回类成员的引用，但是最好用const（因为类成员是不希望被外部修改，而返回一个类内部成员的引用，就相当于给外部提供了一个修改成员的途径）

4. C++面向对象编程的3个基本特征
    （a）封装：将客观事物抽象为类，每个类对其内部的数据和方法（成员函数）实行保护protection（private，protected，public）
    （b）继承
    （c）多态：系统在运行时，能够根据具体类型确定调用哪一个成员函数

5. 深拷贝和浅拷贝
    该问题会出现在类的拷贝函数中。假设一个类的成员变量中存在指针类型，可以用于指向片内存空间，当我们用已有的一个对象去初始化新的对象时，到底是否要给新的
    对象中指针指向的位置new一片新的内存呢？如果new了新的内存，就是深拷贝；如果没有new新的内存，就是浅拷贝；
    对于浅拷贝，在对象释放的过程中会出现问题，如果我们释放了原来的对象，则也释放了成员变量中指针指向的那片内存，则当释放新对象的时候，再次释放这片已经被
    释放的内存就会报错，解决办法就是深拷贝
    
6. 当一个类Kaito中没有申明任何成员变量和成员函数的时候，sizeof(A)的大小是0吗？如果不是0，为什么？
    不是0，因为如果用该类型定义一个数组的时候，比如Kaito p[10]，其中每个元素的大小不知道，则无法获知该开辟多大的空间，所以必须不为0；
    在visual studio中，如果什么都没有，sizeof(Kaito) = 1
    如果有任何普通成员函数，包括构造函数和析构函数，sizeof(Kaito) = 1
    如果有函数被标记为virtual，则需要构建一个虚函数表，这时候就会有一个用于指向虚函数表的指针，就会多个指针的大小，sizeof(Kaito) = 4/8(32位机/64位机)

7. const和#define的区别
    （a）const有数据类型，#define只是字符替换；因此编译器可以对const进行类型检查，但是#define没有
    （b）在一些集成化的调试工具可以对const进行调试，但是#define不行
    （c）#define作用在预处理阶段，const作用在编译阶段

8. 说出const尽可能多的作用
    （a）作用在全局常量，可以防止该常量在程序的任意位置被改变，因为该常量存放在常量区，只读
    （b）作用在函数的形式参数，可以防止函数体内对传入的参数所在内存位置的内容进行修改
    （c）用来修饰指针
        const int* p1;  // 该指针指向的对象只能是const int类型的，但是可以指向任意const int类型的对象
        int const* p2;  // 该指针只能指向一个地址，不能改变其指向的位置
    （d）用在类成员函数的参数列表的后面，表示该函数不能修改类中的成员变量
    （e）作用在类成员函数的返回值，使该返回得到的对象不能被作为左值（即不能对其内容进行修改）

9. 说出static尽可能多的作用
    （a）作用于局部变量，则该变量被存放在静态数据区，在多次调用该变量所在函数时，其值是上一次的值，且在第一次定义的时候，其值初始化为0
    （b）作用在函数名前，表示该函数只能被本文件内的其它函数调用，不能被其它文件使用
    （c）作用在全局变量前，表示该变量只能被本文件使用，不能被其它文件使用（因此其它文件也可以定义相同的变量名），且初始化为0
    （d）作用在类中的成员变量前，所有该类对象共享一份该变量，即该成员变量无论定义多少对象都只有一份
    （e）作用在类成员函数前，所有类对象共用该函数，且该函数不接受this指针，因此无法确定具体对象的成员变量，只能访问static的变量
