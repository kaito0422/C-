vector, list, deque, map

vector：
	操作和数组相似，可以通过[]访问元素；
	可以动态增长其容量，每次当存入元素后发现容量不够，就动态分配原来两倍大小的空间，把原来的数据搬运到新分配的空间中，再释放原来的内存（所以在对vector进行擦如删除操作后，原来的迭代器iterator可能会失效）；
	只有push_back操作，没有push_front操作，但是可以通过迭代器往vector中间插入一个元素，只不过在插入位置往后的所有元素需要重新进行搬移操作；
	当不断从尾部删除元素的过程中，不会去释放多余的空间；
	
list：
	list的组成形式是双向环形链表，可以在任意位置快速插入元素，因为不需要搬运数据，适合大量插入删除操作；
	不能进行随机访问，即不能通过[]进行访问数据，只能通过迭代器遍历链表的形式寻找数据；
	不会浪费空间；
	
deque：
	deque的底层实现比较复杂，其中包含多个buffer，每个buffer的长度固定，每个buffer由一个指针指向其起始地址，这些指针被存放在一个控制中心，控制中心的结构是vector；
	deque可以在front和back两端进行插入删除操作，也可以使用[]进行随机访问；
	使用迭代器在不同的buffer之间进行访问的时候，需要提供一种机制，从iterator返回控制中心（那个vector）来获取下一个buffer的地址，即存在vector中的下一个元素（一个指针，指向下一个buffer的起始地址）

map：
	map的底层实现是红黑树（RB-Tree），因此拥有一些红黑树的特点；
	map中的红黑树设计自平衡的，因此对元素的搜索复杂度为log2(n)；
	其中最小的元素就是红黑树中的最左叶节点；
	通过迭代器对map进行遍历，就得到了键值对应的排序；
	使用的地方，Linux中的CFS调度算法中对进程的记录，进程的执行进度是红黑树的key，而进行描述符（task_struct）就是红黑树中的value，优先级越高的进程执行进度走得越慢，因此每次当记账时间到来的时候，CFS调度器会选择红黑树中的最左叶节点和当前节点的key值进行比较（执行进度），选择较小的进行调度执行，把另外一个插入到红黑树中，红黑树会自动将其放到合适的位置上；
